package com.example.demo;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.JdbcClient;

import java.sql.SQLException;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Proof tests demonstrating that unclosed JDBC streams actually leak connections.
 *
 * <p>These tests create their own isolated connection pool (not using Spring's context)
 * to prove that:</p>
 * <ul>
 *   <li>Unclosed streams hold connections indefinitely</li>
 *   <li>The pool becomes exhausted after N unclosed streams (where N = pool size)</li>
 *   <li>Properly closed streams return connections to the pool</li>
 * </ul>
 *
 * <p>Each test uses a fresh pool with only 2 connections to quickly demonstrate exhaustion.</p>
 */
class ConnectionLeakProofTest {

    private static final int POOL_SIZE = 2;
    private static final int CONNECTION_TIMEOUT_MS = 500;

    private HikariDataSource dataSource;
    private JdbcClient jdbcClient;
    private JdbcTemplate jdbcTemplate;

    private static final RowMapper<String> NAME_MAPPER = (rs, rowNum) -> rs.getString("name");

    @BeforeEach
    void setUp() throws SQLException {
        // Create isolated pool for each test
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:h2:mem:leaktest_" + System.nanoTime() + ";DB_CLOSE_DELAY=-1");
        config.setUsername("sa");
        config.setPassword("");
        config.setMaximumPoolSize(POOL_SIZE);
        config.setMinimumIdle(1);
        config.setConnectionTimeout(CONNECTION_TIMEOUT_MS);

        dataSource = new HikariDataSource(config);
        jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcClient = JdbcClient.create(dataSource);

        // Create test table
        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                name VARCHAR(100) NOT NULL
            )
        """);
        jdbcTemplate.execute("INSERT INTO users (name) VALUES ('Alice'), ('Bob'), ('Charlie')");
    }

    @AfterEach
    void tearDown() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
        }
    }

    // ==================== LEAK PROOF TESTS ====================

    @Test
    @DisplayName("PROOF: JdbcClient.stream() without close exhausts pool")
    void jdbcClientStream_withoutClose_exhaustsPool() {
        // Leak all connections by not closing streams
        for (int i = 0; i < POOL_SIZE; i++) {
            Stream<String> stream = jdbcClient
                    .sql("SELECT * FROM users")
                    .query(NAME_MAPPER)
                    .stream();
            // Intentionally NOT closing - simulating the bug
            stream.forEach(name -> {}); // consume but don't close
        }

        // Verify pool is exhausted
        assertThat(dataSource.getHikariPoolMXBean().getActiveConnections())
                .as("All %d connections should be leaked", POOL_SIZE)
                .isEqualTo(POOL_SIZE);

        // Next attempt should timeout
        assertThatThrownBy(() -> {
            jdbcClient.sql("SELECT * FROM users").query(NAME_MAPPER).stream();
        })
                .as("Pool should be exhausted, new connection should timeout")
                .hasMessageContaining("Failed to obtain JDBC Connection");
    }

    @Test
    @DisplayName("PROOF: JdbcTemplate.queryForStream() without close exhausts pool")
    void jdbcTemplateQueryForStream_withoutClose_exhaustsPool() {
        // Leak all connections
        for (int i = 0; i < POOL_SIZE; i++) {
            Stream<String> stream = jdbcTemplate.queryForStream(
                    "SELECT * FROM users",
                    NAME_MAPPER
            );
            stream.count(); // consume but don't close
        }

        assertThat(dataSource.getHikariPoolMXBean().getActiveConnections())
                .as("All connections should be leaked")
                .isEqualTo(POOL_SIZE);

        assertThatThrownBy(() -> {
            jdbcTemplate.queryForStream("SELECT * FROM users", NAME_MAPPER);
        })
                .hasMessageContaining("Failed to obtain JDBC Connection");
    }

    @Test
    @DisplayName("PROOF: Even partial stream consumption leaks connection")
    void partialStreamConsumption_stillLeaks() {
        // Even if we only read one element, the connection is still leaked
        for (int i = 0; i < POOL_SIZE; i++) {
            Stream<String> stream = jdbcClient
                    .sql("SELECT * FROM users")
                    .query(NAME_MAPPER)
                    .stream();
            stream.findFirst(); // Only read first element, don't close
        }

        assertThat(dataSource.getHikariPoolMXBean().getActiveConnections())
                .as("Connections leak even with partial consumption")
                .isEqualTo(POOL_SIZE);
    }

    @Test
    @DisplayName("PROOF: Stream variable going out of scope does NOT close connection")
    void streamGoingOutOfScope_doesNotClose() {
        for (int i = 0; i < POOL_SIZE; i++) {
            leakConnectionInMethod();
        }

        // Even though stream variables are out of scope, connections are still held
        assertThat(dataSource.getHikariPoolMXBean().getActiveConnections())
                .as("GC doesn't immediately close streams - connections remain leaked")
                .isEqualTo(POOL_SIZE);
    }

    private void leakConnectionInMethod() {
        Stream<String> stream = jdbcClient
                .sql("SELECT * FROM users")
                .query(NAME_MAPPER)
                .stream();
        stream.count();
        // stream goes out of scope here but connection is NOT returned
    }

    // ==================== COMPLIANT PROOF TESTS ====================

    @Test
    @DisplayName("PROOF: try-with-resources properly returns connections")
    void tryWithResources_returnsConnections() {
        int iterations = POOL_SIZE * 20;

        for (int i = 0; i < iterations; i++) {
            try (Stream<String> stream = jdbcClient
                    .sql("SELECT * FROM users")
                    .query(NAME_MAPPER)
                    .stream()) {
                stream.forEach(name -> {});
            }
        }

        // Should complete without timeout - connections were returned
        assertThat(dataSource.getHikariPoolMXBean().getActiveConnections())
                .as("No connections should be leaked after %d iterations", iterations)
                .isLessThanOrEqualTo(1); // May have 1 idle connection
    }

    @Test
    @DisplayName("PROOF: Explicit close() returns connection")
    void explicitClose_returnsConnection() {
        int iterations = POOL_SIZE * 20;

        for (int i = 0; i < iterations; i++) {
            Stream<String> stream = jdbcClient
                    .sql("SELECT * FROM users")
                    .query(NAME_MAPPER)
                    .stream();
            try {
                stream.forEach(name -> {});
            } finally {
                stream.close();
            }
        }

        assertThat(dataSource.getHikariPoolMXBean().getActiveConnections())
                .as("Explicit close should return connections")
                .isLessThanOrEqualTo(1);
    }
}
